GET提交表单时,表单数据会被包含在请求的抽象路径里.抽象路径部分会体现在请求行中.
HTTP协议要求,请求的请求行和消息头所使用的字符集必须为ISO8859-1,该字符集不支持中文.
因此为了满足协议要求,我们不得在其中体现中文内容,意味着表单中的数据若是中文则不得直接
进行提交了.

/regUser?username=范&password=xxx....
不合法,因为抽象路径中包含了ISO8859-1不支持的字符.

解决思路:用ISO8859-1支持的字符来表达其不支持的字符.
字符'1'和'0'这两个字符ISO8859-1支持.

浏览器希望传递中文时,可以先用支持中文的字符集将中文转换为一组字节(一堆2进制)
范---UTF-8--->11101000 10001100 10000011(UTF-8中每个汉字占3字节)

浏览器传递中文时就可以如下操作了:
/regUser?username=111010001000110010000011&password=xxxx....
'
问题解决,但是带来了新问题:1个汉字就要用24个'0'或'1'的字符表示.
为了尽量减少长度带来的传输速度的降低,我们可以将2进制用16进制表示,因为16进制可以用字符
'0'-'9''A'-'F'表示,而英文,数组都是ISO8859-1支持的字符.


二进制             十进制             十六进制
0000                0               0
0001                1               1
0010                2               2
0011                3               3
0100                4               4
0101                5               5
0110                6               6
0111                7               7
1000                8               8
1001                9               9
1010                10              A
1011                11              B
1100                12              C
1101                13              D
1110                14              E
1111                15              F


将2进制以16进制形式表达时:
/regUser?username=E88C83&password=xxxx....
长度问题得到了有效改善.
但是又带来了一个新问题:如何与正常的英文数字组合区分?
例如:
一个用户注册时取名:E88C83
/regUser?username=E88C83&password=xxxx....
服务器应当将E88C83当成16进制看待还是将其当做英文数字E88C83看待?

为了解决该问题,URL规定如果是用16进制表达2进制字节内容时,需要在每两位16进制前必须
添加一个'%'
因此如果浏览器传递的是:
/regUser?username=E88C83&password=xxxx....
那么该用户名就叫:E88C83

如果浏览器传递的是:
/regUser?username=%E8%8C%83&password=xxxx....
则服务器应当认为E8 8C 83是16进制表示3个字节的2进制信息.

如果我们想表达%,由于其是URL地址中的关键字符.因此浏览器传递'%'字符时也会用%XX表达.
