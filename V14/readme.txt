此版本完成用户注册业务操作
上一个版本我们已经将注册页面中表单提交的数据解析完毕并存入到HttpServletRequest对应属性中了

此版本我们完成DispatcherServlet处理请求的环节，增加对业务的处理。

实现:
1:新建一个包:com.webserver.controller
  这个包中保存所有将来用于处理业务的类
2:在controller包中新建处理与用户数据相关的业务类:UserController
3:在UserController中添加reg()方法,用于处理用户注册逻辑
4:在DispatcherServlet处理请求的环节中，首先我们将原来判断路径使用的请求对象中的uri换成
  requestURI.
  原因:uri中可能表示的路径中含有参数，而不是纯请求部分了。
5:如果请求路径是/regUser,则说明这次请求是reg.html页面form表单提交的请求(action决定)
  那么这个请求就是要处理注册业务，因此我们实例化UserController并调用reg方法进行处理即可。

实现重定向

当浏览器提交一个请求时，比如注册，那么请求会带着表单信息请求注册功能。而注册功能处理
完毕后直接设置一个页面给浏览器，这个过程是内部跳转。
即:浏览器上的地址栏中地址显示的是提交表单的请求，而实际看到的是注册结果的提示页面。
这有一个问题，如果此时浏览器刷新，会重复上一次的请求，即:再次提交表单请求注册业务。

为了解决这个问题，我们可以使用重定向。
重定向是当我们处理完请求后，不直接响应一个页面，而是给浏览器回复一个路径，让其再次根据
该路径发起请求。这样一来，无论用户如何刷新，请求的都是该路径。避免表达的重复提交。

实现:
在HttpServletResponse中定义一个方法:sendRedirect()
该方法中设置状态代码为302，并在响应头中包含Location指定需要浏览器重新发起请求的路径
将原来Controller中内部跳转页面的操作全部改为重定向。

重定向的响应格式示例:
HTTP/1.1 302 Moved Temporarily
Location: /have_user.html





